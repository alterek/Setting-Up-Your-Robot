# Подглава 2.3 Архитектура поглощения

Я хочу уделить немного больше времени на идею, лежащую в основе **архитектуры поглощения**, и указать на некоторые особенности того, как мы будем использовать эту концепцию в дизайне проекта нашего робота. Многие из вас знакомы с этой концепцией ещё со школы или университета, поэтому вы можете посмотреть на мою диаграмму и двигаться дальше. Для остальных предлагаю немного поговорить об этой биологически вдохновленной концепции робота.

Архитектура поглощения впервые была описана Родни Бруксом, профессором MIT, который позже помог основать корпорацию iRobot и изобрести робота Baxter. Родни изучал поведение насекомых, чтобы понять, как программировать роботов. До этого времени \(1986 год\) роботы были однопоточными машинами, способными выполнять лишь одно действие в момент времени. Такие существа, как мухи или муравьи, имеют очень простой интеллект, но в то же время умудряются функционировать в реальном мире. Брукс решил, что существует несколько уровней замкнутых процессов обратной связи, протекающих одновременно.

Основная концепция архитектуры поглощения была уточнена и упрощена с того времени. То, что я представлю дальше – мой субъективный взял, моя интерпретация того, как применить данную концепцию к роботу в контексте нашего проекта.

Необходимо, чтобы робот действовал в соответствии с рядом целей. Он не просто реагирует на стимулы по отдельности, а выполняет целенаправленное поведение. Цель может состоять в том, чтобы подобрать игрушку или перемещаться по комнате, избегая препятствия. Парадигма, которую мы создаем, состоит в том, что пользователь ставит цель перед роботом, а робот определяет, как её выполнить, даже если цель тривиальна.

Проблемы начинаются тогда, когда робот выполняет более одной цели одновременно. Например, робот не просто ездит по городу, но также избегает препятствия и ищет игрушки, которые можно забрать. Как же решить, какая из целей имеет больший приоритет? Ответ можно найти на следующей диаграмме:

![](.gitbook/assets/image%20%282%29.png)

Разделим систему принятия решений робота на три уровнях. Каждый из них имеет свой масштаб ответственности и действует в разных временных масштабах. На самых нижних уровнях находится то, что можно назвать автономной нервной системой робота – внутренние функции по поддержанию здоровья и контроля. Эти процессы протекают очень быстро – 20 раз в секунду и имеют дело только с тем, что находится внутри робота \(чтение внутренних датчиков, проверка уровня заряда батареи, чтение и реагирование на сообщения о сердцебиении\). Я назвал этот уровень _береги себя_.

Следующий уровень решает индивидуальные задачи, такие как вождение автомобиля или поиск игрушек. Эти задачи краткосрочные и имеют дело с тем, что могут видеть датчики. Период времени для принятия решений находится на втором диапазоне, поэтому этим задачи могут иметь одну или две частоты обновления, но медленнее, чем внутренние. Я называю этот уровень _выполни задачу_ - вы можете назвать его _управлением транспортным средством_ или _управлением полезной нагрузки_.

Последний, верхний уровень отвечает за _завершение миссии_ и посвящен общей цели робота. На этом уровне есть общий аппарат, отвечающий за поиск игрушек, их подбора и убирания, что является миссией данного робота. С этим уровнем взаимодействуют люди, также он реагирует на команды. Верхний уровень работает с задачами, выполнение которых может занимать минуты или даже часы.

У архитектуры поглощения есть свои правила. Вот моя версия этих правил:

* Каждый уровень сообщается только с соседними слоями.
* Чем ниже уровень, тем выше приоритет.

Я уже приводил пример движения робота по комнате. Нижний уровень обнаруживает препятствия. Средний ведет робота в определенном направлении, а верхний отвечает за цель. Сверху вниз верхний уровень получает команду _очистить комнату_, средний – _объехать её_, а нижний получает команду левого и правого двигателей _идти вперед на 60% дроссельной заслонки_. Теперь нижний уровень обнаруживает препятствие. Он прерывает функцию объезда и переопределяет команду с верхнего уровня, чтобы увернуться от препятствия. Как только он это сделает, управление будет возвращено среднему уровню для определения направления движения. 

Приведу другой пример. Нижний уровень теряет сигнал сердцебиения – значит, что-то не так с программным обеспечением. Двигатели останавливаются, перекрываются любые команды из верхних слоев. Не имеет значения, какие это команды – робот неисправен и должен остановиться. Такой _инвертированный приоритет_ уровней является причиной того, почему мы называем это архитектурой поглощения – нижние уровни приоритетней верхних. 

Главное преимущество такой организации – четко определены события, ошибки или команды, которые имеют приоритет над другими, что позволяет роботу не застрять в петле нерешительности. 

Разные роботы имеют различное количество уровней в своей архитектуре. Также бывает контрольный уровень, который управляет другими роботами. Его команды являются целями для других роботов. Наибольшее количество уровней, которое было в моих проектах – пять. Это был проект по самостоятельному вождению автомобиля.

